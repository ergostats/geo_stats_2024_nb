<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.555">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="ERGOSTATS">

<title>Actividad Propuesta: Análisis Espacial de Amenidades de Salud en Parroquias de Ecuador</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="actividad_propuesta_files/libs/clipboard/clipboard.min.js"></script>
<script src="actividad_propuesta_files/libs/quarto-html/quarto.js"></script>
<script src="actividad_propuesta_files/libs/quarto-html/popper.min.js"></script>
<script src="actividad_propuesta_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="actividad_propuesta_files/libs/quarto-html/anchor.min.js"></script>
<link href="actividad_propuesta_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="actividad_propuesta_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="actividad_propuesta_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="actividad_propuesta_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="actividad_propuesta_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Actividad Propuesta: Análisis Espacial de Amenidades de Salud en Parroquias de Ecuador</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>ERGOSTATS </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<p>Esta actividad te permitirá aplicar y reforzar conceptos clave en el análisis espacial, enfocándote en la relación entre las amenidades de salud y la población a nivel de parroquias en Ecuador. A través de esta práctica, tendrás la oportunidad de trabajar con diferentes fuentes de datos, realizar cálculos de indicadores relevantes, y reflexionar sobre la calidad y precisión de las fuentes de información geográfica. Además, te ayudará a comprender cómo los datos espaciales pueden integrarse y analizarse para obtener insights significativos que apoyen la toma de decisiones.</p>
<section id="parte-1-identificación-y-reflexión-sobre-las-amenidades-de-salud-30-puntos" class="level3">
<h3 class="anchored" data-anchor-id="parte-1-identificación-y-reflexión-sobre-las-amenidades-de-salud-30-puntos">Parte 1: Identificación y Reflexión sobre las Amenidades de Salud (30 puntos)</h3>
<p>Para comenzar, utiliza OpenStreetMap para identificar todas las amenidades de salud disponibles, como hospitales y clínicas, en tu área de estudio. Durante el curso ocupamos al Distrito Metropolitano de Quito pero te motivamos a hacer el análisis con otra parroquia. Te dejamos un enlace para que puedas descargar los códigos DPA de provincias para que puedas buscar una de interés para ti.</p>
<p><a href="https://aplicaciones2.ecuadorencifras.gob.ec/SIN/descargas/cge2022.xls">Codificación de la División Política Administrativa (DPA)</a></p>
<p>Este enlace es una descarga directa para un archivo de tipo <code>.xls</code>. Por ejemplo:<br>
<br>
<img src="images/clipboard-1167930683.png" class="img-fluid"></p>
<p>Para la parroquia de Guaranda el código DPA es “020150” de la provincia de Bolivar con código “02”. con el cual podrás identificar en las distintas bases de datos a esta parroquia. En OpenStreet maps atraves de la librería <code>osmdata</code> deberás emplear un texto como “Guaranda, Ecuador” en la consulta. La idea es que puedas agregar los resultados de tu consulta a nivel de parroquia con la <em>Geodatabase del INEC.</em></p>
<p><strong>Con esta tarea, te enfocarás en:</strong></p>
<ul>
<li>Identificar y seleccionar amenidades de salud en OpenStreetMap, utilizando funciones como <code>add_osm_feature()</code> y <code>osmdata_sf()</code> para buscar y filtrar las diferentes categorías de servicios de salud disponibles.</li>
<li>Reportar cuántas amenidades encontraste utilizando funciones como <code>nrow()</code> para contar los elementos y realizar un análisis inicial de su distribución espacial.</li>
</ul>
<p>Una vez que hayas identificado estas amenidades, reflexiona sobre los límites y la precisión de los datos obtenidos. Considera la cobertura de OpenStreetMap en tu área de estudio: ¿faltan algunas amenidades? ¿Qué tan representativa es la información en comparación con la realidad observable? Escribe un párrafo compartiendo algunas ideas sobre los límites de OpenStreetMap, y asegúrate de incluir en este párrafo el número total de amenidades de salud que encontraste en tu región de estudio.</p>
<p><strong>Pistas:</strong> Puedes utilizar funciones como <code>map()</code>, <code>reduce()</code> para iterar sobre múltiples <code>features</code> y combinar resultados. Piensa en cómo podrías cuantificar y reportar estas amenidades, y cómo podrías estructurar tu reflexión basándote en los datos que encuentras (o no encuentras). Encontrarás la Wiki de Open Street Maps en el enlace:</p>
<p><a href="https://wiki.openstreetmap.org/wiki/Map_features">Wiki de OpenStreetMaps Features</a></p>
</section>
<section id="parte-2-unión-de-polígonos-de-zonas-censales-a-nivel-de-parroquias-20-puntos" class="level3">
<h3 class="anchored" data-anchor-id="parte-2-unión-de-polígonos-de-zonas-censales-a-nivel-de-parroquias-20-puntos">Parte 2: Unión de Polígonos de Zonas Censales a Nivel de Parroquias (20 puntos)</h3>
<p>Después de identificar las amenidades de salud, realiza la unión de los polígonos de las zonas censales a nivel de parroquia. En este punto deberás primero filtrar las zonas censales para una provincia y luego realizar la unión de los poligonos de las zonas censales para armar los polígonos de parroquias.</p>
<p><a href="https://www.ecuadorencifras.gob.ec/documentos/web-inec/Geografia_Estadistica/Documentos/GEODATABASE_NACIONAL_2021.zip">Descarga el Marco Geoestadístico 2021 o Geodata Base</a></p>
<p><strong>Con esta tarea, aprenderás a:</strong></p>
<ul>
<li>Unir los polígonos de las zonas censales utilizando un identificador común para agrupar los datos por parroquia, utilizando funciones como <code>st_union()</code> de la librería <code>sf</code>.</li>
<li>Crear un identificador parroquial que te permitirá analizar la información de salud a este nivel, aplicando <code>mutate()</code> y <code>str_sub()</code> de <code>dplyr</code> para manipular los códigos de zona censal.</li>
</ul>
<p><strong>Pistas:</strong> Para lograr esta unión, piensa en cómo puedes utilizar los identificadores geográficos de las zonas censales, la variable es <code>zon</code>. Por ejemplo, podrías extraer los primeros dígitos del código de zona censal con <code>str_sub()</code> para unificar los datos a nivel parroquial, cantonal o provincial.</p>
</section>
<section id="parte-3-cálculo-del-número-total-de-amenidades-15-puntos" class="level3">
<h3 class="anchored" data-anchor-id="parte-3-cálculo-del-número-total-de-amenidades-15-puntos">Parte 3: Cálculo del Número Total de Amenidades (15 puntos)</h3>
<p>Con la información de las parroquias y las amenidades de salud identificadas, realizarás una unión espacial para determinar cuántas amenidades se encuentran dentro de cada parroquia. Para mostrar los resultados de la distribución de hospitales realiza un mapa de calor con la librería <code>ggplot2</code>, te recomendamos revisar las funciones <code>geom_sf</code>, <code>scale_fill_gradient</code>, y <code>theme</code> para darle un formato adecuado a tu gráfico, y la función <code>labs</code> para etiquetarlo adecuadamente. En Quarto tienes opciones como <code>echo</code>, <code>message</code>, <code>fig.height</code>, y otras opciones para presentar tu gráfico con una breve descripción e interpretación.</p>
<p><strong>Con esta tarea, te enfocarás en:</strong></p>
<ul>
<li>Realizar una unión espacial utilizando <code>st_join()</code> de la librería <code>sf</code>, configurando el argumento <code>join = st_within</code> para asociar cada amenidad de salud con la parroquia en la que se encuentra.</li>
<li>Contar las amenidades por parroquia para entender mejor la distribución de servicios de salud en tu área de estudio, utilizando funciones como <code>group_by()</code> y <code>summarise()</code> de <code>dplyr</code>.</li>
<li>Preparar la información para un análisis de correlación espacial posterior.</li>
<li>Realizar un mapa de calor y realizar una breve interpretación de la distribución de las amenidades de salud en las parroquias de la provincia que hayan priorizado para el análisis.</li>
</ul>
<p><strong>Pistas:</strong> Primero, realiza la unión espacial con <code>st_join()</code> donde <code>join = st_within</code> para asociar cada amenidad de salud con su respectiva parroquia. Este paso asegura que solo se consideren las amenidades que están dentro de los límites de cada parroquia. Luego, utiliza <code>group_by()</code> para agrupar los datos por parroquia y <code>summarise()</code> para contar cuántas amenidades existen en cada una. Este conteo te permitirá analizar la densidad y distribución de servicios de salud en las diferentes parroquias.</p>
</section>
<section id="parte-4-cálculo-del-ratio-de-amenidades-por-habitante-15-puntos" class="level3">
<h3 class="anchored" data-anchor-id="parte-4-cálculo-del-ratio-de-amenidades-por-habitante-15-puntos">Parte 4: Cálculo del Ratio de Amenidades por Habitante (15 puntos)</h3>
<p>A continuación, calcula el ratio del número de amenidades seleccionadas en relación con el número de habitantes por cada 100 habitantes en cada parroquia. Este indicador te permitirá analizar la disponibilidad de servicios de salud en relación con la población. Durante la clase empleamos los resultados de la estructura poblacional del Ecuador, el cual lo puedes volver a descargar en el siguiente enlace.</p>
<p><a href="https://www.censoecuador.gob.ec/wp-content/uploads/2024/04/01_2022_CPV_Estructura_poblacional_CSV.zip">Resultados Poblacionales 2022 (INEC)</a></p>
<p><strong>Con esta tarea, aprenderás a:</strong></p>
<ul>
<li>Integrar datos de población y amenidades utilizando <code>left_join()</code> de <code>dplyr</code> y calcular un indicador clave de disponibilidad de servicios con <code>mutate()</code>.</li>
<li>Interpretar este indicador en el contexto de la distribución de la población.</li>
<li>Presentar la distribución del indicador en las parroquias de la provincia de análisis.</li>
</ul>
<p><strong>Pistas:</strong> Piensa en cómo puedes unir los datos demográficos con los de amenidades usando <code>left_join()</code>, y cómo calcular un ratio que refleje la relación entre la cantidad de servicios de salud y la población en cada parroquia con <code>mutate()</code>.</p>
</section>
<section id="parte-5-cálculo-del-índice-de-moran-para-el-indicador-de-amenidades-de-salud-20-puntos" class="level3">
<h3 class="anchored" data-anchor-id="parte-5-cálculo-del-índice-de-moran-para-el-indicador-de-amenidades-de-salud-20-puntos">Parte 5: Cálculo del Índice de Moran para el Indicador de Amenidades de Salud (20 puntos)</h3>
<p>Para profundizar en el análisis espacial, calcularás el Índice de Moran para el indicador de número de amenidades de salud por cada 100 habitantes en las parroquias de una provincia. Este índice te permitirá evaluar si existe autocorrelación espacial en la distribución de las amenidades de salud, lo cual es clave para entender la distribución y concentración de estos servicios en diferentes áreas.</p>
<p><strong>Con esta tarea, te enfocarás en:</strong></p>
<ul>
<li>Calcular el Índice de Moran utilizando la función <code>moran.test()</code> de la librería <code>spdep</code>, aplicándolo al indicador que mide el número de amenidades de salud por cada 100 habitantes.</li>
<li>Calcular el Índice de Moran local utilizando la función <code>localmoran``()</code> de la librería <code>spdep</code>, aplicándolo al indicador que mide el número de amenidades de salud por cada 100 habitantes.</li>
<li>Interpretar el resultado del Índice de Moran para determinar si existe un patrón de autocorrelación espacial (positiva, negativa o nula) en la distribución de las amenidades de salud en las parroquias.</li>
</ul>
<p><strong>Pistas:</strong> Primero, asegúrate de haber calculado correctamente el indicador de número de amenidades de salud por cada 100 habitantes en cada parroquia y reempleza los elementos vacios con 0 para los casos en que no existan amenidades. Construye la matriz de vecindad <code>poly2nb</code> con un modelo de vecindad <em>Queen.</em> Luego, construye una matriz de pesos espaciales utilizando la función <code>nb2listw()</code> de la librería <code>spdep</code>. Finalmente, calcula el Índice de Moran con <code>moran.test()</code> y analiza los resultados para entender cómo las amenidades de salud se agrupan o dispersan en el espacio.</p>
</section>
<section id="parte-6-actividad-opcional-análisis-de-buffers-y-reflexión-sobre-los-límites-de-openstreetmap-20-puntos" class="level3">
<h3 class="anchored" data-anchor-id="parte-6-actividad-opcional-análisis-de-buffers-y-reflexión-sobre-los-límites-de-openstreetmap-20-puntos">Parte 6: Actividad opcional, Análisis de Buffers y Reflexión sobre los Límites de OpenStreetMap (20 puntos)</h3>
<p>Para profundizar en tu análisis, crea un buffer de 500 metros alrededor de tu lugar de trabajo, universidad o cualquier lugar de tu elección empleando el elemento con las zonas censales. Verifica si dentro de este buffer se encuentran las amenidades de salud que identificaste previamente. Luego, realiza una caminata por el área del buffer y compara la información obtenida de OpenStreetMap con la realidad observable.</p>
<p><strong>Con esta tarea, te enfocarás en:</strong></p>
<ul>
<li>Crear buffers alrededor de puntos de interés utilizando <code>st_buffer()</code> de la librería <code>sf</code>, y verificar la presencia de amenidades dentro de esos buffers con <code>st_intersects()</code> o <code>st_within()</code>.</li>
<li>Reflexionar sobre las diferencias entre los datos geográficos obtenidos y la realidad observada, evaluando la precisión y los límites de OpenStreetMap.</li>
</ul>
<p><strong>Pistas:</strong> Considera cómo utilizar <code>st_buffer()</code> para crear un área alrededor de tu punto de interés y <code>st_intersects()</code> o <code>st_within()</code> para verificar si hay amenidades dentro de ese área. Reflexiona sobre las limitaciones de los datos geográficos en la práctica y cómo estas diferencias pueden afectar tu análisis.</p>
</section>
<section id="entrega-del-trabajo-total-120-puntos" class="level3">
<h3 class="anchored" data-anchor-id="entrega-del-trabajo-total-120-puntos">Entrega del Trabajo (Total: 120 puntos)</h3>
<p>Finalmente, entrega tu trabajo como un documento Quarto que combine el código y la narrativa de la actividad, tal como hemos realizado en las actividades anteriores en clase. Este enfoque no solo te permitirá mostrar tus habilidades técnicas, sino que también te ayudará a desarrollar habilidades de documentación y presentación, esenciales para cualquier análisis de datos.</p>
<p>Sube el enlace al repositorio en el Issue de GitHub en el siguiente.</p>
<p><a href="https://github.com/ergostats/geo_stats_julio_2024/issues/2">Sube aquí tu trabajo.</a></p>
<p><strong>Criterios de evaluación:</strong></p>
<ul>
<li>Correcta creación y entrega del documento Quarto combinando texto, código y gráficos.</li>
<li>Inclusión de un archivo README en GitHub que explique brevemente el contenido del documento y los pasos realizados.</li>
<li>Claridad y organización en la presentación tanto del documento Quarto como del repositorio en GitHub.</li>
</ul>
</section>
<section id="consejos-finales" class="level3">
<h3 class="anchored" data-anchor-id="consejos-finales">Consejos Finales</h3>
<p>Recuerda documentar tu código en el documento Quarto explicando cada paso que realizas. Esto no solo facilita la comprensión de tu trabajo para otros, sino también para ti mismo en el futuro. Revisa tus resultados para asegurarte de que todo está correcto y considera la posibilidad de colaborar con tus compañeros para enriquecer el análisis y el aprendizaje.</p>
<p>Esta actividad te ofrece una oportunidad para aplicar tus conocimientos en un contexto real, desarrollando habilidades que son esenciales en el análisis espacial y en la ciencia de datos en general. ¡Disfruta del proceso de aprendizaje y sigue explorando!</p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>